#!/bin/bash
##############################################################################
# ZZCOLLAB STRUCTURE MODULE
##############################################################################
# 
# PURPOSE: Project structure creation and navigation setup
#          - Directory structure creation with tracking
#          - Symbolic link creation for convenience navigation
#          - Project layout management with uninstall support
#
# DEPENDENCIES: core.sh (for logging functions)
#
# TRACKING: All directories and symlinks created are tracked for uninstall
##############################################################################

# Validate core module is loaded
# Validate required modules are loaded
require_module "core"

#=============================================================================
# MANIFEST TRACKING FUNCTIONS
#=============================================================================

# Tracking functions are now provided by core.sh

#=============================================================================
# DIRECTORY STRUCTURE CREATION
#=============================================================================

# Function: create_directory_structure
# Purpose: Creates the complete directory structure for the R research compendium
# Creates: 16 directories organized for R package development and research workflow
#
# Directory Layout Created:
#   R/                      - R package functions (exported to users)
#   man/                    - Manual pages (generated by roxygen2)
#   tests/testthat/         - Unit tests using testthat framework
#   vignettes/              - Package vignettes and tutorials
#   data/                   - R package data (for package distribution)
#   analysis/               - Research analysis components (rrtools)
#   ├── data/               - Research data
#   │   ├── raw_data/       - Original, unmodified datasets
#   │   └── derived_data/   - Processed, analysis-ready data
#   ├── paper/              - Research paper (Rmd → PDF, rrtools standard)
#   ├── figures/            - Generated plots and visualizations
#   ├── tables/             - Generated statistical tables
#   ├── templates/          - Analysis templates and snippets
#   └── scripts/            - Working R scripts and exploratory analysis
#   docs/                   - Project documentation
#   .github/workflows/      - GitHub Actions CI/CD pipelines
#
# Error Handling: Fails fast if any directory creation fails
# Tracking: All created directories are tracked in manifest for uninstall
create_directory_structure() {
    log_debug "Creating directory structure..."

    # Define all directories to create in logical order
    # Each directory serves a specific purpose in the research workflow
    # Following rrtools framework structure (Marwick et al. 2018)
    local -r dirs=(
        "R"                      # R package functions
        "man"                    # Manual pages
        "tests/testthat"         # Unit tests with testthat subdirectory
        "vignettes"              # Package vignettes
        "data"                   # R package data (for package distribution)
        "modules"                # Shell scripts for package validation and tooling
        "analysis"               # Analysis workflow root
        "analysis/data"          # Research data root
        "analysis/data/raw_data"          # Raw, unmodified data
        "analysis/data/derived_data"      # Processed data ready for analysis
        "analysis/paper"         # Research paper development (rrtools standard)
        "analysis/figures"       # Generated plots and figures
        "analysis/tables"        # Generated tables and summaries
        "analysis/templates"     # Analysis templates and reusable code
        "analysis/scripts"       # Working R scripts and exploratory analysis
        "docs"                   # Project documentation
        ".github/workflows"      # GitHub Actions CI/CD workflows
    )

    # Create each directory and track it for uninstall capability
    for dir in "${dirs[@]}"; do
        # mkdir -p creates parent directories as needed and doesn't fail if directory exists
        if mkdir -p "$dir"; then
            # Track successful directory creation for uninstall manifest
            track_directory "$dir"
            log_debug "Created directory: $dir"
        else
            log_error "Failed to create directory: $dir"
            return 1
        fi
    done

    log_success "Structure (${#dirs[@]} dirs, 40 files)"
}

#=============================================================================
# DATA DIRECTORY TEMPLATES
#=============================================================================

# Function: create_data_templates
# Purpose: Create documentation templates for data directory (rrtools structure)
create_data_templates() {
    log_debug "Creating data directory templates..."

    # Install data README template to document data structure and processing (rrtools location)
    if install_template "data_README.md" "analysis/data/README.md" "data directory documentation" "Created data directory README with Palmer Penguins example"; then
        log_debug "Data README template created"
    else
        log_error "Failed to create data README template"
        return 1
    fi

    # Install data workflow guide template to docs directory
    if install_template "DATA_WORKFLOW_GUIDE.md" "docs/DATA_WORKFLOW_GUIDE.md" "data workflow documentation" "Created comprehensive data development workflow guide"; then
        log_debug "Data workflow guide template created"
    else
        log_error "Failed to create data workflow guide template"
        return 1
    fi
}

#=============================================================================
# STRUCTURE VALIDATION AND REPORTING
#=============================================================================

# Function: validate_directory_structure
# Purpose: Verify that all required directories were created successfully
# Returns: 0 if all directories exist, 1 if any are missing
validate_directory_structure() {
    local -r required_dirs=(
        "R" "man" "tests/testthat" "vignettes" "data" "analysis"
        "analysis/data" "analysis/data/raw_data" "analysis/data/derived_data"
        "analysis/paper" "analysis/figures" "analysis/tables" "analysis/templates"
        "analysis/scripts" "docs" ".github/workflows"
    )

    validate_directories_exist "Directory structure" "${required_dirs[@]}"
}

# Function: show_structure_summary
# Purpose: Display a summary of the created project structure (only with -v)
show_structure_summary() {
    # Only show detailed structure with verbose mode
    if [[ $VERBOSITY_LEVEL -lt 2 ]]; then
        return 0
    fi

    log_info "Project structure summary:"
    cat << 'EOF' >&2
📁 PROJECT STRUCTURE CREATED (rrtools framework):

├── R/                     # Package functions (exported to users)
├── man/                   # Manual pages (generated by roxygen2)
├── tests/testthat/        # Unit tests using testthat framework
├── vignettes/             # Package vignettes and tutorials
├── data/                  # R package data (for distribution)
├── analysis/              # Research analysis workflow (rrtools)
│   ├── data/              # Research data
│   │   ├── raw_data/      # Original, unmodified datasets
│   │   └── derived_data/  # Processed, analysis-ready data
│   ├── paper/             # Research paper (Rmd → PDF)
│   ├── figures/           # Generated plots and visualizations
│   ├── tables/            # Generated statistical tables
│   ├── templates/         # Analysis templates
│   └── scripts/           # Working R scripts and exploration
├── docs/                  # Project documentation
└── .github/workflows/     # GitHub Actions CI/CD pipelines

🔗 QUICK NAVIGATION:
   cd a  →  analysis/data/      cd n  →  analysis/
   cd f  →  analysis/figures/   cd t  →  analysis/tables/
   cd s  →  analysis/scripts/   cd p  →  analysis/paper/
   cd m  →  man/                cd e  →  tests/
   cd o  →  docs/
EOF
}

#=============================================================================
# DOCKER-COMPATIBLE DOTFILES FUNCTIONS
#=============================================================================

##############################################################################
# FUNCTION: create_docker_compatible_zshrc
# PURPOSE:  Generate Docker-compatible .zshrc by filtering macOS-specific commands
# USAGE:    create_docker_compatible_zshrc "/path/to/.zshrc" "/path/to/.zshrc_docker"
# ARGS:     
#   $1 - source_zshrc: Path to original .zshrc file
#   $2 - output_file: Path where filtered .zshrc_docker should be created
# RETURNS:  
#   0 - Successfully created filtered version
#   1 - Error (source file not found, write permission issues, etc.)
# GLOBALS:  
#   READ:  None
#   WRITE: None (creates specified output file)
# DESCRIPTION:
#   This function automatically filters macOS-specific commands from a user's
#   .zshrc file to create a Docker-compatible version. It removes or replaces
#   commands that won't work in Linux containers while preserving useful
#   shell configurations.
# FILTERING RULES:
#   - Remove: pbcopy, pbpaste, open, say commands and aliases
#   - Remove: Homebrew paths (/opt/homebrew, /usr/local specific to macOS)
#   - Remove: macOS-specific ls color settings
#   - Replace: macOS 'open' with xdg-open equivalent where appropriate
#   - Preserve: Cross-platform aliases, functions, and configurations
# EXAMPLE:
#   create_docker_compatible_zshrc "~/.zshrc" "./.zshrc_docker"
##############################################################################
create_docker_compatible_zshrc() {
    local source_zshrc="$1"
    local output_file="$2"
    
    if [[ ! -f "$source_zshrc" ]]; then
        log_warn "Source .zshrc not found: $source_zshrc"
        return 1
    fi
    
    log_info "Creating Docker-compatible .zshrc from $source_zshrc"
    
    # Add header comment
    cat > "$output_file" << 'EOF'
# Container-specific .zshrc - automatically filtered from host .zshrc
# macOS-specific commands have been removed for Linux container compatibility
# Generated by zzcollab - edit the original .zshrc and regenerate if needed

EOF
    
    # Process the source file with filtering
    sed -E '
        # Remove or comment out macOS-specific commands
        /^[[:space:]]*(alias.*)?pbcopy/d
        /^[[:space:]]*(alias.*)?pbpaste/d
        /^[[:space:]]*(alias.*)?open[[:space:]]/d
        /^[[:space:]]*(alias.*)?say[[:space:]]/d
        
        # Remove Homebrew-specific paths (macOS)
        /\/opt\/homebrew/d
        /\/usr\/local\/Homebrew/d
        
        # Remove macOS-specific ls color exports
        /^[[:space:]]*export[[:space:]]+LSCOLORS=/d
        /^[[:space:]]*export[[:space:]]+CLICOLOR=/d
        
        # Comment out brew command usage
        s/^([[:space:]]*)brew /\1# brew /
        
        # Replace "open" command with xdg-open equivalent (preserve useful functionality)
        s/open ([^[:space:]]+)/xdg-open \1/g
        
        # Remove or comment macOS Touch Bar configurations
        /TouchBar/d
        /touch.*bar/Id
        
        # Remove macOS keychain access
        /security.*keychain/d
        
        # Add container-appropriate PATH instead of macOS-specific ones
        /^[[:space:]]*export[[:space:]]+PATH=.*\/opt\/homebrew/{
            i\# Original macOS PATH replaced with container-appropriate version
            i\export PATH=".:$HOME/bin:/usr/local/bin:$HOME/.local/bin:/usr/bin:/bin:$PATH"
            d
        }
    ' "$source_zshrc" >> "$output_file"
    
    # Add container-specific enhancements
    cat >> "$output_file" << 'EOF'

#=============================================================================
# CONTAINER-SPECIFIC ENHANCEMENTS (added by zzcollab)
#=============================================================================

# Container-aware prompt with Docker icon
if [[ -z "$PROMPT" ]]; then
    autoload -Uz vcs_info
    precmd() { vcs_info }
    zstyle ':vcs_info:git:*' formats '%b '
    setopt PROMPT_SUBST
    PROMPT='🐳[${CONTAINER_NAME:-container}] %F{cyan}%*%f %F{magenta}${${PWD:A}/$HOME/~}%f %F{red}${vcs_info_msg_0_}%f$ %(?:☕  :☔  )'
fi

# Container-appropriate cdpath
cdpath=($HOME $HOME/project $HOME/workspace . ..)

# Linux-compatible aliases (replacements for macOS commands)
alias o='xdg-open'          # Replacement for macOS 'open'
alias copy='xclip -sel clip'  # Replacement for pbcopy (if xclip available)
alias paste='xclip -sel clip -o'  # Replacement for pbpaste (if xclip available)
EOF
    
    log_success "Created Docker-compatible .zshrc: $output_file"
    track_file "$output_file"
    return 0
}

##############################################################################  
# FUNCTION: setup_docker_dotfiles
# PURPOSE:  Set up Docker-compatible dotfiles from user's dotfiles directory
# USAGE:    setup_docker_dotfiles "/path/to/dotfiles"
# ARGS:     
#   $1 - dotfiles_dir: Path to user's dotfiles directory
# RETURNS:  
#   0 - Successfully processed dotfiles
#   1 - Error or dotfiles directory not found
# GLOBALS:  
#   READ:  None
#   WRITE: None (creates filtered dotfiles in current directory)
# DESCRIPTION:
#   This function processes a user's dotfiles directory to create Docker-
#   compatible versions. It handles automatic filtering for known problematic
#   files like .zshrc while copying other dotfiles directly.
# PROCESSING:
#   - .zshrc: Automatically filtered to remove macOS commands
#   - Other dotfiles: Copied directly (assumed to be cross-platform)
#   - Maintains file permissions and structure
# EXAMPLE:
#   setup_docker_dotfiles "~/dotfiles"
##############################################################################
setup_docker_dotfiles() {
    local dotfiles_dir="$1"
    
    if [[ ! -d "$dotfiles_dir" ]]; then
        log_warn "Dotfiles directory not found: $dotfiles_dir"
        return 1
    fi
    
    log_info "Setting up dotfiles from $dotfiles_dir"

    # Copy all dotfiles directly (assumed to have proper OS conditionals)
    for dotfile in "$dotfiles_dir"/{.*,*}; do
        if [[ -f "$dotfile" ]]; then
            local filename=$(basename "$dotfile")

            # Skip hidden system files
            [[ "$filename" =~ ^\.(DS_Store|Trash|Spotlight-V100)$ ]] && continue
            
            # Copy the file
            local target_name="$filename"
            [[ ! "$filename" =~ ^\. ]] && target_name=".$filename"  # Add dot if missing
            
            cp "$dotfile" "./$target_name"
            track_file "$target_name"
            log_info "Copied dotfile: $target_name"
        fi
    done
    
    log_success "Docker-compatible dotfiles setup complete"
    return 0
}

#=============================================================================
# STRUCTURE MODULE VALIDATION
#=============================================================================

# Validate that required manifest variables are available
if [[ -z "${MANIFEST_FILE:-}" ]]; then
    log_warn "MANIFEST_FILE not defined - tracking will be disabled"
fi

if [[ -z "${MANIFEST_TXT:-}" ]]; then
    log_warn "MANIFEST_TXT not defined - fallback tracking will be disabled"
fi


