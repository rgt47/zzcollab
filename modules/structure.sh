#!/bin/bash
##############################################################################
# ZZCOLLAB STRUCTURE MODULE
##############################################################################
# 
# PURPOSE: Project structure creation and navigation setup
#          - Directory structure creation with tracking
#          - Symbolic link creation for convenience navigation
#          - Project layout management with uninstall support
#
# DEPENDENCIES: core.sh (for logging functions)
#
# TRACKING: All directories and symlinks created are tracked for uninstall
##############################################################################

# Validate core module is loaded
# Validate required modules are loaded
require_module "core"

#=============================================================================
# MANIFEST TRACKING FUNCTIONS
#=============================================================================

# Tracking functions are now provided by core.sh

#=============================================================================
# DIRECTORY STRUCTURE CREATION
#=============================================================================

# Function: create_directory_structure
# Purpose: Creates the complete directory structure for the R research compendium
# Creates: 18 directories organized for R package development and research workflow
# 
# Directory Layout Created:
#   R/                      - R package functions (exported to users)
#   man/                    - Manual pages (generated by roxygen2)
#   tests/testthat/         - Unit tests using testthat framework
#   vignettes/              - Package vignettes and tutorials
#   data/                   - Data management root directory
#   ├── raw_data/           - Original, unmodified datasets
#   ├── derived_data/       - Processed, analysis-ready data
#   ├── metadata/           - Data dictionaries and documentation
#   └── validation/         - Data quality reports and validation
#   analysis/               - Research analysis components
#   ├── report/              - Research paper (Rmd → PDF)
#   ├── figures/            - Generated plots and visualizations
#   ├── tables/             - Generated statistical tables
#   └── templates/          - Analysis templates and snippets
#   scripts/                - Working R scripts and exploratory analysis
#   archive/                - Archived files and old versions
#   docs/                   - Project documentation
#   .github/workflows/      - GitHub Actions CI/CD pipelines
#
# Error Handling: Fails fast if any directory creation fails
# Tracking: All created directories are tracked in manifest for uninstall
create_directory_structure() {
    log_info "Creating directory structure..."
    
    # Define all directories to create in logical order
    # Each directory serves a specific purpose in the research workflow
    local -r dirs=(
        "R"                      # R package functions
        "man"                    # Manual pages
        "tests/testthat"         # Unit tests with testthat subdirectory
        "vignettes"              # Package vignettes
        "data"                   # Data management root
        "data/raw_data"          # Raw, unmodified data
        "data/derived_data"      # Processed data ready for analysis
        "data/metadata"          # Data documentation and dictionaries
        "data/validation"        # Data quality and validation reports
        "analysis"               # Analysis workflow root
        "analysis/report"         # Research paper development
        "analysis/figures"       # Generated plots and figures
        "analysis/tables"        # Generated tables and summaries
        "analysis/templates"     # Analysis templates and reusable code
        "scripts"                # Working scripts and exploration
        "archive"                # Archived and legacy files
        "docs"                   # Project documentation
        ".github/workflows"      # GitHub Actions CI/CD workflows
    )
    
    # Create each directory and track it for uninstall capability
    for dir in "${dirs[@]}"; do
        # mkdir -p creates parent directories as needed and doesn't fail if directory exists
        if mkdir -p "$dir"; then
            # Track successful directory creation for uninstall manifest
            track_directory "$dir"
            log_info "Created directory: $dir"
        else
            log_error "Failed to create directory: $dir"
            return 1
        fi
    done
    
    log_success "Directory structure created (${#dirs[@]} directories)"
}

#=============================================================================
# DATA DIRECTORY TEMPLATES
#=============================================================================

# Function: create_data_templates
# Purpose: Create documentation templates for data directory
create_data_templates() {
    log_info "Creating data directory templates..."
    
    # Install data README template to document data structure and processing
    if install_template "data_README.md" "data/README.md" "data directory documentation" "Created data directory README with Palmer Penguins example"; then
        log_success "Data README template created"
    else
        log_error "Failed to create data README template"
        return 1
    fi
    
    # Install data workflow guide template
    if install_template "DATA_WORKFLOW_GUIDE.md" "DATA_WORKFLOW_GUIDE.md" "data workflow documentation" "Created comprehensive data development workflow guide"; then
        log_success "Data workflow guide template created"
    else
        log_error "Failed to create data workflow guide template"
        return 1
    fi
}

#=============================================================================
# NAVIGATION SCRIPTS CREATION (replaces symbolic links)
#=============================================================================

# Function: create_navigation_scripts
# Purpose: Creates navigation_scripts.sh that generates one-letter navigation links
# Creates: A single navigation_scripts.sh file that can create navigation shortcuts
#
# Navigation Links Created:
#   a → ./data                 - Quick access to data directory
#   n → ./analysis             - Quick access to analysis directory
#   f → ./analysis/figures     - Quick access to figures
#   t → ./analysis/tables      - Quick access to tables
#   s → ./scripts              - Quick access to scripts
#   m → ./man                  - Quick access to manual pages
#   e → ./tests                - Quick access to tests
#   o → ./docs                 - Quick access to documentation
#   c → ./archive              - Quick access to archive
#   p → ./analysis/report      - Quick access to report directory
#
# Usage Examples:
#   ./navigation_scripts.sh    # Create navigation links
#   cd a                       # Go to data directory
#   cd n                       # Go to analysis directory
#   ./navigation_scripts.sh -c # Remove all navigation links
#
# Note: Creates symbolic links for easier navigation
create_navigation_scripts() {
    log_info "Creating navigation scripts..."
    
    # Create navigation_scripts.sh that generates one-letter navigation links
    cat > navigation_scripts.sh << 'EOF'
#!/bin/bash
# Navigation Links Generator
# Creates one-letter symbolic links for quick directory navigation
# Usage: ./navigation_scripts.sh [--clean | -c]
#   --clean | -c : Remove all navigation links

# Function to clean up navigation links
cleanup_links() {
    echo "Removing navigation links..."
    rm -f a n f t s m e o c p
    echo "All navigation links removed."
    exit 0
}

# Check for cleanup flag
if [[ "$1" == "--clean" || "$1" == "-c" ]]; then
    cleanup_links
fi

echo "Creating navigation symbolic links..."

# Remove existing navigation links first
rm -f a n f t s m e o c p

# Create symbolic links for existing directories
if [[ -d "./data" ]]; then
    ln -sf "./data" a
    echo "Created: a → ./data"
fi

if [[ -d "./analysis" ]]; then
    ln -sf "./analysis" n
    echo "Created: n → ./analysis"
fi

if [[ -d "./analysis/figures" ]]; then
    ln -sf "./analysis/figures" f
    echo "Created: f → ./analysis/figures"
fi

if [[ -d "./analysis/tables" ]]; then
    ln -sf "./analysis/tables" t
    echo "Created: t → ./analysis/tables"
fi

if [[ -d "./scripts" ]]; then
    ln -sf "./scripts" s
    echo "Created: s → ./scripts"
fi

if [[ -d "./man" ]]; then
    ln -sf "./man" m
    echo "Created: m → ./man"
fi

if [[ -d "./tests" ]]; then
    ln -sf "./tests" e
    echo "Created: e → ./tests"
fi

if [[ -d "./docs" ]]; then
    ln -sf "./docs" o
    echo "Created: o → ./docs"
fi

if [[ -d "./archive" ]]; then
    ln -sf "./archive" c
    echo "Created: c → ./archive"
fi

if [[ -d "./analysis/report" ]]; then
    ln -sf "./analysis/report" p
    echo "Created: p → ./analysis/report"
fi

echo "Navigation symbolic links created successfully!"
echo "Usage: cd a (data), cd n (analysis), cd p (report), etc."
echo "To remove all links: ./navigation_scripts.sh --clean"
EOF

    chmod +x navigation_scripts.sh
    log_success "Navigation links generator created: navigation_scripts.sh"
    log_info "Run './navigation_scripts.sh' to create navigation shortcuts"
    log_info "Run './navigation_scripts.sh --clean' to remove all shortcuts"
}

#=============================================================================
# STRUCTURE VALIDATION AND REPORTING
#=============================================================================

# Function: validate_directory_structure
# Purpose: Verify that all required directories were created successfully
# Returns: 0 if all directories exist, 1 if any are missing
validate_directory_structure() {
    local -r required_dirs=(
        "R" "man" "tests/testthat" "vignettes" "data" "data/raw_data"
        "data/derived_data" "data/metadata" "data/validation" "analysis"
        "analysis/report" "analysis/figures" "analysis/tables" "analysis/templates"
        "scripts" "archive" "docs" ".github/workflows"
    )
    
    validate_directories_exist "Directory structure" "${required_dirs[@]}"
}

# Function: show_structure_summary
# Purpose: Display a summary of the created project structure
show_structure_summary() {
    log_info "Project structure summary:"
    cat << 'EOF'
📁 PROJECT STRUCTURE CREATED:

├── R/                     # Package functions (exported to users)
├── man/                   # Manual pages (generated by roxygen2)  
├── tests/testthat/        # Unit tests using testthat framework
├── vignettes/             # Package vignettes and tutorials
├── data/                  # Data management
│   ├── raw_data/          # Original, unmodified datasets
│   ├── derived_data/      # Processed, analysis-ready data
│   ├── metadata/          # Data dictionaries and documentation
│   └── validation/        # Data quality reports
├── analysis/              # Research analysis workflow
│   ├── report/             # Research paper (Rmd → PDF)
│   ├── figures/           # Generated plots and visualizations
│   ├── tables/            # Generated statistical tables
│   └── templates/         # Analysis templates
├── scripts/               # Working R scripts and exploration
├── archive/               # Archived files and old versions
├── docs/                  # Project documentation
├── .github/workflows/     # GitHub Actions CI/CD pipelines
└── Symbolic links (a→data, n→analysis, p→paper, etc.)

🔗 QUICK NAVIGATION:
   cd a  →  data/           cd n  →  analysis/
   cd f  →  figures/        cd t  →  tables/
   cd s  →  scripts/        cd p  →  report/
   cd m  →  man/            cd e  →  tests/
   cd o  →  docs/           cd c  →  archive/
EOF
}

#=============================================================================
# DOCKER-COMPATIBLE DOTFILES FUNCTIONS
#=============================================================================

##############################################################################
# FUNCTION: create_docker_compatible_zshrc
# PURPOSE:  Generate Docker-compatible .zshrc by filtering macOS-specific commands
# USAGE:    create_docker_compatible_zshrc "/path/to/.zshrc" "/path/to/.zshrc_docker"
# ARGS:     
#   $1 - source_zshrc: Path to original .zshrc file
#   $2 - output_file: Path where filtered .zshrc_docker should be created
# RETURNS:  
#   0 - Successfully created filtered version
#   1 - Error (source file not found, write permission issues, etc.)
# GLOBALS:  
#   READ:  None
#   WRITE: None (creates specified output file)
# DESCRIPTION:
#   This function automatically filters macOS-specific commands from a user's
#   .zshrc file to create a Docker-compatible version. It removes or replaces
#   commands that won't work in Linux containers while preserving useful
#   shell configurations.
# FILTERING RULES:
#   - Remove: pbcopy, pbpaste, open, say commands and aliases
#   - Remove: Homebrew paths (/opt/homebrew, /usr/local specific to macOS)
#   - Remove: macOS-specific ls color settings
#   - Replace: macOS 'open' with xdg-open equivalent where appropriate
#   - Preserve: Cross-platform aliases, functions, and configurations
# EXAMPLE:
#   create_docker_compatible_zshrc "~/.zshrc" "./.zshrc_docker"
##############################################################################
create_docker_compatible_zshrc() {
    local source_zshrc="$1"
    local output_file="$2"
    
    if [[ ! -f "$source_zshrc" ]]; then
        log_warn "Source .zshrc not found: $source_zshrc"
        return 1
    fi
    
    log_info "Creating Docker-compatible .zshrc from $source_zshrc"
    
    # Add header comment
    cat > "$output_file" << 'EOF'
# Container-specific .zshrc - automatically filtered from host .zshrc
# macOS-specific commands have been removed for Linux container compatibility
# Generated by zzcollab - edit the original .zshrc and regenerate if needed

EOF
    
    # Process the source file with filtering
    sed -E '
        # Remove or comment out macOS-specific commands
        /^[[:space:]]*(alias.*)?pbcopy/d
        /^[[:space:]]*(alias.*)?pbpaste/d
        /^[[:space:]]*(alias.*)?open[[:space:]]/d
        /^[[:space:]]*(alias.*)?say[[:space:]]/d
        
        # Remove Homebrew-specific paths (macOS)
        /\/opt\/homebrew/d
        /\/usr\/local\/Homebrew/d
        
        # Remove macOS-specific ls color exports
        /^[[:space:]]*export[[:space:]]+LSCOLORS=/d
        /^[[:space:]]*export[[:space:]]+CLICOLOR=/d
        
        # Comment out brew command usage
        s/^([[:space:]]*)brew /\1# brew /
        
        # Replace "open" command with xdg-open equivalent (preserve useful functionality)
        s/open ([^[:space:]]+)/xdg-open \1/g
        
        # Remove or comment macOS Touch Bar configurations
        /TouchBar/d
        /touch.*bar/Id
        
        # Remove macOS keychain access
        /security.*keychain/d
        
        # Add container-appropriate PATH instead of macOS-specific ones
        /^[[:space:]]*export[[:space:]]+PATH=.*\/opt\/homebrew/{
            i\# Original macOS PATH replaced with container-appropriate version
            i\export PATH=".:$HOME/bin:/usr/local/bin:$HOME/.local/bin:/usr/bin:/bin:$PATH"
            d
        }
    ' "$source_zshrc" >> "$output_file"
    
    # Add container-specific enhancements
    cat >> "$output_file" << 'EOF'

#=============================================================================
# CONTAINER-SPECIFIC ENHANCEMENTS (added by zzcollab)
#=============================================================================

# Container-aware prompt with Docker icon
if [[ -z "$PROMPT" ]]; then
    autoload -Uz vcs_info
    precmd() { vcs_info }
    zstyle ':vcs_info:git:*' formats '%b '
    setopt PROMPT_SUBST
    PROMPT='🐳[${CONTAINER_NAME:-container}] %F{cyan}%*%f %F{magenta}${${PWD:A}/$HOME/~}%f %F{red}${vcs_info_msg_0_}%f$ %(?:☕  :☔  )'
fi

# Container-appropriate cdpath
cdpath=($HOME $HOME/project $HOME/workspace . ..)

# Linux-compatible aliases (replacements for macOS commands)
alias o='xdg-open'          # Replacement for macOS 'open'
alias copy='xclip -sel clip'  # Replacement for pbcopy (if xclip available)
alias paste='xclip -sel clip -o'  # Replacement for pbpaste (if xclip available)
EOF
    
    log_success "Created Docker-compatible .zshrc: $output_file"
    track_file "$output_file"
    return 0
}

##############################################################################  
# FUNCTION: setup_docker_dotfiles
# PURPOSE:  Set up Docker-compatible dotfiles from user's dotfiles directory
# USAGE:    setup_docker_dotfiles "/path/to/dotfiles"
# ARGS:     
#   $1 - dotfiles_dir: Path to user's dotfiles directory
# RETURNS:  
#   0 - Successfully processed dotfiles
#   1 - Error or dotfiles directory not found
# GLOBALS:  
#   READ:  None
#   WRITE: None (creates filtered dotfiles in current directory)
# DESCRIPTION:
#   This function processes a user's dotfiles directory to create Docker-
#   compatible versions. It handles automatic filtering for known problematic
#   files like .zshrc while copying other dotfiles directly.
# PROCESSING:
#   - .zshrc: Automatically filtered to remove macOS commands
#   - Other dotfiles: Copied directly (assumed to be cross-platform)
#   - Maintains file permissions and structure
# EXAMPLE:
#   setup_docker_dotfiles "~/dotfiles"
##############################################################################
setup_docker_dotfiles() {
    local dotfiles_dir="$1"
    
    if [[ ! -d "$dotfiles_dir" ]]; then
        log_warn "Dotfiles directory not found: $dotfiles_dir"
        return 1
    fi
    
    log_info "Setting up dotfiles from $dotfiles_dir"

    # Copy all dotfiles directly (assumed to have proper OS conditionals)
    for dotfile in "$dotfiles_dir"/{.*,*}; do
        if [[ -f "$dotfile" ]]; then
            local filename=$(basename "$dotfile")

            # Skip hidden system files
            [[ "$filename" =~ ^\.(DS_Store|Trash|Spotlight-V100)$ ]] && continue
            
            # Copy the file
            local target_name="$filename"
            [[ ! "$filename" =~ ^\. ]] && target_name=".$filename"  # Add dot if missing
            
            cp "$dotfile" "./$target_name"
            track_file "$target_name"
            log_info "Copied dotfile: $target_name"
        fi
    done
    
    log_success "Docker-compatible dotfiles setup complete"
    return 0
}

#=============================================================================
# STRUCTURE MODULE VALIDATION
#=============================================================================

# Validate that required manifest variables are available
if [[ -z "${MANIFEST_FILE:-}" ]]; then
    log_warn "MANIFEST_FILE not defined - tracking will be disabled"
fi

if [[ -z "${MANIFEST_TXT:-}" ]]; then
    log_warn "MANIFEST_TXT not defined - fallback tracking will be disabled"
fi


